// app/api/assessment-invitations/route.ts
// API for creating, managing, and looking up assessment invitations

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import { neon } from '@neondatabase/serverless';

const sql = neon(process.env.DATABASE_URL!);

// GET - List invitations for an organization
export async function GET(request: NextRequest) {
    try {
        const session = await getServerSession(authOptions);
        if (!session?.user) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }

        const { searchParams } = new URL(request.url);
        const organizationId = searchParams.get('organization_id');
        const participantId = searchParams.get('participant_id');
        const status = searchParams.get('status') || 'pending';

        if (!organizationId) {
            return NextResponse.json({ error: 'organization_id required' }, { status: 400 });
        }

        let query = `
            SELECT 
                ai.*,
                p.first_name as participant_first_name,
                p.last_name as participant_last_name,
                p.preferred_name as participant_preferred_name,
                p.phone as participant_phone,
                p.email as participant_email,
                u.first_name as pss_first_name,
                u.last_name as pss_last_name
            FROM assessment_invitations ai
            JOIN participants p ON ai.participant_id = p.id
            JOIN users u ON ai.created_by = u.id
            WHERE ai.organization_id = $1
        `;
        const params: any[] = [organizationId];
        let paramIndex = 2;

        if (status !== 'all') {
            query += ` AND ai.status = $${paramIndex}`;
            params.push(status);
            paramIndex++;
        }

        if (participantId) {
            query += ` AND ai.participant_id = $${paramIndex}`;
            params.push(participantId);
            paramIndex++;
        }

        query += ` ORDER BY ai.created_at DESC LIMIT 100`;

        const invitations = await sql(query, params);

        return NextResponse.json({
            success: true,
            invitations,
        });

    } catch (error) {
        console.error('Error fetching invitations:', error);
        return NextResponse.json({ error: 'Failed to fetch invitations' }, { status: 500 });
    }
}

// POST - Create a new invitation
export async function POST(request: NextRequest) {
    try {
        const session = await getServerSession(authOptions);
        if (!session?.user) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }

        const body = await request.json();
        const {
            organization_id,
            participant_id,
            assessment_type = 'mirc28',
            message,
            sent_via,
            expires_days = 30,
        } = body;

        if (!organization_id || !participant_id) {
            return NextResponse.json(
                { error: 'organization_id and participant_id required' },
                { status: 400 }
            );
        }

        // Get internal user ID from Cognito sub
        const cognitoSub = (session.user as any).sub || session.user.id;
        const userResult = await sql`
            SELECT id FROM users WHERE cognito_sub = ${cognitoSub}
        `;

        if (!userResult || userResult.length === 0) {
            return NextResponse.json({ error: 'User not found' }, { status: 404 });
        }

        const userId = userResult[0].id;

        // Generate expiration date
        const expiresAt = expires_days 
            ? new Date(Date.now() + expires_days * 24 * 60 * 60 * 1000).toISOString()
            : null;

        // Create invitation (token auto-generated by trigger)
        const result = await sql`
            INSERT INTO assessment_invitations (
                organization_id,
                participant_id,
                created_by,
                assessment_type,
                message,
                sent_via,
                sent_at,
                expires_at
            ) VALUES (
                ${organization_id},
                ${participant_id},
                ${userId},
                ${assessment_type},
                ${message || null},
                ${sent_via || null},
                ${sent_via ? new Date().toISOString() : null},
                ${expiresAt}
            )
            RETURNING *
        `;

        const invitation = result[0];

        // Fetch participant info for response
        const participantResult = await sql`
            SELECT first_name, last_name, preferred_name, phone, email
            FROM participants
            WHERE id = ${participant_id}
        `;

        return NextResponse.json({
            success: true,
            invitation: {
                ...invitation,
                participant: participantResult[0],
            },
            share_url: `${process.env.PARTICIPANT_APP_URL || 'https://participant-assessment-app.vercel.app'}/a/${invitation.token}`,
        });

    } catch (error) {
        console.error('Error creating invitation:', error);
        return NextResponse.json({ error: 'Failed to create invitation' }, { status: 500 });
    }
}

// PATCH - Update invitation (cancel, resend, etc.)
export async function PATCH(request: NextRequest) {
    try {
        const session = await getServerSession(authOptions);
        if (!session?.user) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }

        const body = await request.json();
        const { invitation_id, action, sent_via } = body;

        if (!invitation_id || !action) {
            return NextResponse.json(
                { error: 'invitation_id and action required' },
                { status: 400 }
            );
        }

        let result;

        switch (action) {
            case 'cancel':
                result = await sql`
                    UPDATE assessment_invitations
                    SET status = 'cancelled', updated_at = NOW()
                    WHERE id = ${invitation_id}
                    RETURNING *
                `;
                break;

            case 'resend':
                result = await sql`
                    UPDATE assessment_invitations
                    SET 
                        sent_via = ${sent_via || 'link'},
                        sent_at = NOW(),
                        updated_at = NOW()
                    WHERE id = ${invitation_id}
                    RETURNING *
                `;
                break;

            case 'extend':
                result = await sql`
                    UPDATE assessment_invitations
                    SET 
                        expires_at = NOW() + INTERVAL '30 days',
                        updated_at = NOW()
                    WHERE id = ${invitation_id}
                    RETURNING *
                `;
                break;

            default:
                return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
        }

        return NextResponse.json({
            success: true,
            invitation: result[0],
        });

    } catch (error) {
        console.error('Error updating invitation:', error);
        return NextResponse.json({ error: 'Failed to update invitation' }, { status: 500 });
    }
}
